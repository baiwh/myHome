函数也是一种数据类型

参数列表相当于函数的入口，return相当于函数的出口

#定义函数

* 语句式(最快，优先解释)
	* function test(){};
* 直接量（es推荐）
	* var test=function(){};
* 构造函数（顶级作用域）
	* var test=new Function("a","b","return a+b;");

#参数

* 形参
	* function test(形参列表){}
	* 形参个数和实参个数可以不一样
	* 
* 实参
* 函数的参数个数
	* test.length
* 访问函数的实际参数
	* arguments
	* 实际参数的个数arguments.length
	* 第一个实际参数arguments[0]
	* 只能在函数内部使用
	* arguments.callee指向函数自己本身，对这个函数的引用。和函数名没有任何关系

#this

* 对象是指在运行时期基于执行环境所绑定的。
* 总是指向调用者。

#call、apply

* 每个函数都包含的两个非继承而来的方法
* 在特定的作用域中调用函数。实际上等于设置函数体内this对象的值
* function sum(x,y){
	* return x+y;}
* function call(n1,n2){
	* return sum.call(this,n1,n2);}		传数
* function apply(n1,n2){
	* return sum.apply(this,[n1,n2]);}		传数组
* 扩充函数赖以运行的作用域。且不会有耦合

#执行环境和作用域链

* 环境变量可以一层一层的向上进行追溯。可以访问他的上级环境（变量和函数）
* 尽量少用全局变量。因为全局变量总是最后搜索。影响效率

#垃圾收集和块级作用域

* 垃圾收集方法：标记法、引用计数法
* js和Java不同。js没有块级作用域的概念。js认为只有当函数执行完毕后才进行垃圾回收。Java中for和if有块级作用域。
* 给一个函数增加块级作用域
	* (function (){...})();
	* 第一个括号让函数自己形成一个块级作用域。第二个括号让这个匿名函数执行。

#闭包

* 一个函数可以访问另一个函数作用域中的变量
* 封闭性：private起到一个保护变量的作用
	* var name="A";
	* var obj={
		* name:"B",
		* getName:function(){
			* var o=this;
			* return function(){
				* return o.name;
			* }
		* }
	* }
* 当函数返回的是一个函数时。下一级作用域引用了上一级作用域中的变量。当这个函数完成的时候。这个被引用的变量不会被回收。

#原型
* prototype：
	* 每个函数都有的属性。实际上是一个指针。指向一个对象。这个对象包含可以由 [特定类型] 的所有实例 [共享] 的属性和方法。
* 原型对象：
	* 实际是一个构造函数的实例对象。js中每个对象都有一个原型对象。构造函数的所有实例，共享原型对象所包含的所有属性和方法（继承）。
* 判断原型的方法：
	* isPrototypeOf(实例对象)
* 每次代码读取一个对象的属性的时候：
	* 首先搜索实例对象里的属性
	* 如果没有。再搜索对应点原型对象
	* 如果还没有。返回undefined
* 如果实例对象中存在这个属性。还想取得原型对象中的属性值
	* 用delete xx.xx。删除实例对象中的属性（数据恢复）
* 获取当前对象里的所有keys（属性名），返回一个数组
	* Object.keys();
	* Object.keys(p1);
	* Object.keys(p.prototype);
* 不能被枚举的属性：
	* constructor
* 枚举对象所有属性，不管能不能被枚举
	* Object.
* 原型的弊端：
	* 原型里所有属性和方法被所有对象所共享。修改也会相互影响
	* 解决方法：组合使用原型和构造函数（定义一个类）
* 动态原型模式
	* 把代码都封装到一起
	* function person(...){
		* ......
		* if(typeof this.name !="function"){
			* person.prototype.name=function(){}
		* }
	* }
* 稳妥构造函数式
	* 非常安全的环境
		* 没有公共属性。不能用this
	* function person(...){
		* var obj =new Object();	//创建一个要返回的对象
		* var sex="男";		//定义一个稀有的变量和函数
		* ovj.name=function(){
			* alert(sex);
		* }
		* return obj;
	* }
* 继承：让子类的原型对象等于父类的实例
	* 此时的原型对象将包含一个指向另一个原型的指针
	* 相应的另一个原型中也包含着一个指向另一个构造函数的指针
	* 子类的原型对象的构造器变成了父类的构造器
	* 子类的实例可以访问父类原型对象的所有方法和属性
* 原型继承：
	* 即继承了父类的模板，又继承了父类的原型对象
	* 子类.prototype=new 父类(参数);
* 类继承：
	* 只继承模板。不继承原型对象（借用构造函数的方式继承）
	* 父类的原型对象并没有继承
	* 父类.call(this,参数，参数);
* 原型继承+借用构造函数继承=混合继承
	* 